# Today I Learned(TIL) Wiki

## 25.01.23
---
### Redis 환경 설정 트러블슈팅

Docker를 통한 Redis 컨테이너 실행 시 ping/pong은 정상 작동했으나 실제 연결에 문제 발생했습니다. 
Redis Windows 실행 파일(.exe)을 직접 설치하여 연결 문제 해결했습니다. 
개발 환경에 따라 동일한 서비스도 다른 접근 방식이 필요할 수 있을 것 같습니다. 

### Swagger 문서 연동 및 필터 설정

API 문서화를 위한 Swagger 연동 과정에서 필터 관련 이슈 해결
API 경로와 필터 설정의 중요성을 인식했습니다.
웹 API 경로와 필터에서 처리되는 API 경로를 세밀하게 확인하는 과정의 중요성 파악했습니다. 


### 기능 명세서 작성

프론트엔드와 백엔드 기능을 포괄하는 종합적인 기능 명세서 작성
전체 시스템의 기능을 체계적으로 정리하여 문서화

### UI/UX 디자인

Figma를 활용하여 로그인 페이지 디자인 작업 수행
사용자 인터페이스 디자인 경험 축적



## 25.01.22
---
### 설정 관리 모범 사례

환경 변수와 Spring 프로퍼티의 명명 규칙에 대해 학습했습니다. 환경 변수는 `OPENVIDU_URL`처럼 대문자와 언더스코어를 사용하고, Spring 프로퍼티는 `openvidu.url`처럼 소문자와 점을 사용합니다. Spring 프로퍼티는 `@Value` 어노테이션과 자연스럽게 통합되어 사용하기 편리했습니다.

### 설정 파일 구조

application.properties에서는 다음과 같이 환경 변수를 참조할 수 있습니다:

```
property.name: ${환경변수명:기본값}
openvidu.url: ${OPENVIDU_URL:http://localhost:4443/}

```

설정 파일을 application.properties와 .env로 분리함으로써 보안을 강화할 수 있었습니다. 민감한 정보는 .env 파일에 보관하고, application.properties는 구조만 정의하여 실제 값이 노출되지 않도록 했습니다. 또한 여러 환경에서의 설정 관리가 용이해졌고, Spring 관례를 따르면서 더 나은 통합성을 제공할 수 있었습니다.

### React 컴포넌트 현대화

클래스형 컴포넌트를 함수형 컴포넌트로 전환하면서 많은 것을 배웠습니다. `this.state`를 `useState` 훅으로 교체하니 코드가 더 간결해졌고, 생명주기 메서드를 `useEffect`로 변환하면서 부수 효과를 더 잘 분리할 수 있었습니다.

```jsx

// 클래스형 컴포넌트의 state를 함수형으로 변환// 변환 전
this.state = { count: 0 }
// 변환 후
const [count, setCount] = useState(0)

```

메서드들은 `useCallback`을 사용해 최적화했고, 클래스 필드들은 적절한 훅으로 전환했습니다. 생성자에서 하던 초기화 작업도 훅을 사용해 더 깔끔하게 처리할 수 있었습니다.

### OpenVidu 통합 아키텍처

OpenVidu를 통합하면서 클라이언트와 서버의 역할 분담을 명확히 할 수 있었습니다. React 클라이언트에서는 OpenVidu Browser 라이브러리를 사용해 비디오 스트림과 UI를 처리했고, Spring Boot 서버에서는 OpenVidu Server API를 통해 세션 생성과 토큰 발급을 담당했습니다. 이러한 구조 덕분에 화상 채팅 기능을 효율적으로 구현할 수 있었습니다.


### Node.js와 React 호환성

Node.js v20로 React를 만들었는데 OpenSSL 오류가 발생했습니다. Node.js v18은 안정성 문제가 있어

Node.js v16.20.2이 React 18과 가장 안정적임을 알게되었고, 해당 버전으로 프로젝트를 구축했습니다.

### 데이터베이스 설계 고려사항

S3에 이미지를 저장할 때 url이 varchar 255를 넘는 것을 고려해 text 형식으로 변경했습니다.

1. **버킷명 저장**
    - 최대 길이: 63자
    - 권장: VARCHAR(255)로 여유 확보
    - 향후 요구사항 고려
2. **이미지 URL 저장**
    - VARCHAR(500) 또는 TEXT 타입 권장
    - URL은 매우 길 수 있음 (버킷명 + 리전 + 폴더구조 + 파일명)
    - 가능한 가장 긴 URL 고려

### CORS 설정

`allowCredentials`가 true일 때는 특정 origin 정의 필요

자격 증명 사용 시 와일드카드(*) 사용 불가해서 CORS allowCredentials를 false로 변경하고 명시적으로 origin을 정의했습니다.

### 의존성 관리

React 프로젝트를 시작하는데 web-vitals 핵심 패키지가 없어서 실행에 어려움을 겪었습니다. 또한 node.js와 react 버전 때문에 프로젝트 실행이 안되었습니다. 명시적으로 버전을 지정하고 호환성을 확인했습니다.

## 25.01.21
---
### webRTC - openvidu 서버 구현
**Openvidu Server**: 실시간 오디오 및 비디오 스트리밍에 필요한 모든 인프라를 제공한다. 화상회의 서비스 개발을 위해서 단순히 배포만 하면 된다.

**Application Server(BE)**: client의 요청에 따라 openvidu server와 상호작용하며 세션을 생성하고 관리한다. Openvidu Server에서 제공하는 REST API를 통해서 Openvidu Server와 통신한다.

**Application Client(FE)**: 사용자와 직접 상호작용하는 부분으로, Openvidu library를 사용하여 비디오 세션을 생성하고 관리한다.

webRTC의 연결방식에는 Mesh, MCU, SFU 등 여러 방식이 존재한다. Openvidu는 이 중 SFU 방식을 사용한다. SFU 방식에서 각 peer는 Server에게만 자신의 stream을 보내며, 서버는 해당 stream을 다른 client들에게 보낸댜. (1개의 uplink와 N-1개에 해당하는 downlink)

## 25.01.20
---
### 영상 편집 UI/UX 설계

**영상 편집 화면 구성요소 수집**

주요 영상 편집 툴들의 핵심 기능 및 UI 패턴 분석
필수 편집 도구와 기능들을 카테고리별로 정리
사용자 워크플로우를 고려한 기능 우선순위 설정
수집한 레퍼런스를 바탕으로 최적화된 UI/UX 설계 방향 도출


**피그마 프로토타입 구현**

영상 편집 화면의 전반적인 레이아웃과 인터페이스 디자인 작업 완료
타임라인, 미디어 라이브러리, 프리뷰 창 등 주요 편집 기능 영역 구조화
직관적인 사용자 경험을 위한 UI 요소 배치 및 인터랙션 플로우 설계



## 25.01.17
---
### WebRTC 구현
다대다(N:N) 화상통화 구현을 위해 Mesh, SFU, MCU 방식을 공부했습니다.

**Mesh 토폴로지**

모든 피어가 서로 직접 연결되는 방식
장점: 지연시간이 짧고 구현이 간단
단점: 참여자가 많아지면 네트워크/CPU 부하가 급증
적합한 상황: 소규모(3-4명) 화상통화


**SFU(Selective Forwarding Unit)**

중앙 서버가 각 참여자의 스트림을 다른 참여자들에게 전달
장점: Mesh보다 효율적이고 확장성이 좋음
단점: 중앙 서버 필요, 약간의 지연 발생
적합한 상황: 중규모(~10명) 화상통화


**MCU(Multipoint Control Unit)**

모든 스트림을 서버에서 혼합하여 단일 스트림으로 전송
장점: 클라이언트 부하가 매우 낮음, 대규모 지원
단점: 서버 비용이 높고, 지연시간이 더 김
적합한 상황: 대규모(10명 이상) 화상통화

## 25.01.16
---
### GraphDB
- Neo4j를 활용한 그래프 데이터베이스 구축 방법을 학습했습니다
- Neo4j Sandbox를 이용해 온라인에서 무료로 그래프 DB를 실험할 수 있음을 알게 되었습니다
- Cypher 언어를 사용하여 그래프 데이터의 노드와 관계를 추가하는 방법을 익혔습니다

### API 문서 작성
- ERD(Entity Relationship Diagram)를 완성하고, 이를 바탕으로 API 문서 작성을 시작했습니다
- API 문서에 각 엔드포인트의 요청 방식(GET, POST, PUT, DELETE 등), 파라미터, 응답 예시 등을 상세히 기록했습니다
- PUT과 PATCH 메서드의 차이점을 학습했습니다:
    - PUT: 리소스 전체를 교체
    - PATCH: 리소스의 일부만 수정

### Jira 스프린트 시작
- Jira에서 스크럼 프로젝트를 생성하고 스프린트 보드를 설정했습니다
- 팀원들과 함께 스프린트 계획 회의를 진행하여 각 작업의 목표와 예상 소요 시간을 논의했습니다
- 팀원들의 일정을 Jira에 업로드하고, 'Start Sprint' 버튼을 클릭하여 스프린트를 공식적으로 시작했습니다
- 스프린트 기간을 2주로 설정하고, 팀원들에게 역할과 책임을 명확히 전달했습니다

### 채팅 설계
- 읽음 표시 기능이 있는 채팅 시스템 구현을 위해 연구를 진행했습니다.
- 메시지 상태 관리 방법과 실시간 업데이트 메커니즘에 대해 학습했습니다.
- 데이터베이스 스키마에 메시지 읽음 상태를 추가하는 방안을 고려했습니다.
- WebSocket 또는 Server-Sent Events를 사용한 실시간 통신 방식을 검토했습니다.


## 25.01.15
---
### 기획
- 사용자 요구 분석
- 파생된 음악을 찾기 위한 방안을 논의
- 2D 그래프화로 연관관계 전체 분석하기 위해 GraphDB를 사용하기로 결정
    - 복잡한 음악 간 연관관계를 효과적으로 표현하기 위해 선택
    - Neo4j 등 주요 GraphDB 솔루션 비교 분석
    - 데이터 모델링 및 쿼리 최적화 전략 수립

### 어려웠던 점
- GraphDB를 처음 알게되어서 구조를 만드는데 오랜 시간이 걸렸습니다.
관계형 DB와 다른 패러다임 적응에 시간 소요되었고, 노드와 관계 설계 시 최적의 구조 도출에 어려움이 있었습니다.
Cypher 쿼리 언어 학습에 필요한 시간 투자해야 합니다.

## 25.01.14
---
### 기획
- 와이어프레임 작성하면서 세부 기능들 확정.
- 채팅) 메시지 읽음/안읽음 표시
    
### 어려웠던 점.
- 각자가 생각하고 있는 그림이 달라서 장단점을 비교하는데 시간이 오래 걸렸습니다.
- 기술적으로 큰 그림이 그려지지 않아 설계하는 데 어려움을 겪었습니다.

## 25.01.13
---
### 기획
- 프로젝트 명 확정
    - Blendeo (Blend + video)
- 비디오 루프스테이션 대상 설정
    - ABC 로 동영상이 쌓였다면, 사이의 동영상 수정 및 삭제 불가능.

### 설계
- 백로그 작성
- 기능 설계 

### DB
- erdCloud 로 협업
    - git 과 유사하게, 동영상 fork 하는 방식 토의
