# Today I Learned(TIL) Wiki

## 25.01.21
---
### webRTC - openvidu 서버 구현
**Openvidu Server**: 실시간 오디오 및 비디오 스트리밍에 필요한 모든 인프라를 제공한다. 화상회의 서비스 개발을 위해서 단순히 배포만 하면 된다.

**Application Server(BE)**: client의 요청에 따라 openvidu server와 상호작용하며 세션을 생성하고 관리한다. Openvidu Server에서 제공하는 REST API를 통해서 Openvidu Server와 통신한다.

**Application Client(FE)**: 사용자와 직접 상호작용하는 부분으로, Openvidu library를 사용하여 비디오 세션을 생성하고 관리한다.

webRTC의 연결방식에는 Mesh, MCU, SFU 등 여러 방식이 존재한다. Openvidu는 이 중 SFU 방식을 사용한다. SFU 방식에서 각 peer는 Server에게만 자신의 stream을 보내며, 서버는 해당 stream을 다른 client들에게 보낸댜. (1개의 uplink와 N-1개에 해당하는 downlink)

## 25.01.20
---
### 영상 편집 UI/UX 설계

**영상 편집 화면 구성요소 수집**

주요 영상 편집 툴들의 핵심 기능 및 UI 패턴 분석
필수 편집 도구와 기능들을 카테고리별로 정리
사용자 워크플로우를 고려한 기능 우선순위 설정
수집한 레퍼런스를 바탕으로 최적화된 UI/UX 설계 방향 도출


**피그마 프로토타입 구현**

영상 편집 화면의 전반적인 레이아웃과 인터페이스 디자인 작업 완료
타임라인, 미디어 라이브러리, 프리뷰 창 등 주요 편집 기능 영역 구조화
직관적인 사용자 경험을 위한 UI 요소 배치 및 인터랙션 플로우 설계



## 25.01.17
---
### WebRTC 구현
다대다(N:N) 화상통화 구현을 위해 Mesh, SFU, MCU 방식을 공부했습니다.

**Mesh 토폴로지**

모든 피어가 서로 직접 연결되는 방식
장점: 지연시간이 짧고 구현이 간단
단점: 참여자가 많아지면 네트워크/CPU 부하가 급증
적합한 상황: 소규모(3-4명) 화상통화


**SFU(Selective Forwarding Unit)**

중앙 서버가 각 참여자의 스트림을 다른 참여자들에게 전달
장점: Mesh보다 효율적이고 확장성이 좋음
단점: 중앙 서버 필요, 약간의 지연 발생
적합한 상황: 중규모(~10명) 화상통화


**MCU(Multipoint Control Unit)**

모든 스트림을 서버에서 혼합하여 단일 스트림으로 전송
장점: 클라이언트 부하가 매우 낮음, 대규모 지원
단점: 서버 비용이 높고, 지연시간이 더 김
적합한 상황: 대규모(10명 이상) 화상통화

## 25.01.16
---
### GraphDB
- Neo4j를 활용한 그래프 데이터베이스 구축 방법을 학습했습니다
- Neo4j Sandbox를 이용해 온라인에서 무료로 그래프 DB를 실험할 수 있음을 알게 되었습니다
- Cypher 언어를 사용하여 그래프 데이터의 노드와 관계를 추가하는 방법을 익혔습니다

### API 문서 작성
- ERD(Entity Relationship Diagram)를 완성하고, 이를 바탕으로 API 문서 작성을 시작했습니다
- API 문서에 각 엔드포인트의 요청 방식(GET, POST, PUT, DELETE 등), 파라미터, 응답 예시 등을 상세히 기록했습니다
- PUT과 PATCH 메서드의 차이점을 학습했습니다:
    - PUT: 리소스 전체를 교체
    - PATCH: 리소스의 일부만 수정

### Jira 스프린트 시작
- Jira에서 스크럼 프로젝트를 생성하고 스프린트 보드를 설정했습니다
- 팀원들과 함께 스프린트 계획 회의를 진행하여 각 작업의 목표와 예상 소요 시간을 논의했습니다
- 팀원들의 일정을 Jira에 업로드하고, 'Start Sprint' 버튼을 클릭하여 스프린트를 공식적으로 시작했습니다
- 스프린트 기간을 2주로 설정하고, 팀원들에게 역할과 책임을 명확히 전달했습니다

### 채팅 설계
- 읽음 표시 기능이 있는 채팅 시스템 구현을 위해 연구를 진행했습니다.
- 메시지 상태 관리 방법과 실시간 업데이트 메커니즘에 대해 학습했습니다.
- 데이터베이스 스키마에 메시지 읽음 상태를 추가하는 방안을 고려했습니다.
- WebSocket 또는 Server-Sent Events를 사용한 실시간 통신 방식을 검토했습니다.


## 25.01.15
---
### 기획
- 사용자 요구 분석
- 파생된 음악을 찾기 위한 방안을 논의
- 2D 그래프화로 연관관계 전체 분석하기 위해 GraphDB를 사용하기로 결정
    - 복잡한 음악 간 연관관계를 효과적으로 표현하기 위해 선택
    - Neo4j 등 주요 GraphDB 솔루션 비교 분석
    - 데이터 모델링 및 쿼리 최적화 전략 수립

### 어려웠던 점
- GraphDB를 처음 알게되어서 구조를 만드는데 오랜 시간이 걸렸습니다.
관계형 DB와 다른 패러다임 적응에 시간 소요되었고, 노드와 관계 설계 시 최적의 구조 도출에 어려움이 있었습니다.
Cypher 쿼리 언어 학습에 필요한 시간 투자해야 합니다.

## 25.01.14
---
### 기획
- 와이어프레임 작성하면서 세부 기능들 확정.
- 채팅) 메시지 읽음/안읽음 표시
    
### 어려웠던 점.
- 각자가 생각하고 있는 그림이 달라서 장단점을 비교하는데 시간이 오래 걸렸습니다.
- 기술적으로 큰 그림이 그려지지 않아 설계하는 데 어려움을 겪었습니다.

## 25.01.13
---
### 기획
- 프로젝트 명 확정
    - Blendeo (Blend + video)
- 비디오 루프스테이션 대상 설정
    - ABC 로 동영상이 쌓였다면, 사이의 동영상 수정 및 삭제 불가능.

### 설계
- 백로그 작성
- 기능 설계 

### DB
- erdCloud 로 협업
    - git 과 유사하게, 동영상 fork 하는 방식 토의
