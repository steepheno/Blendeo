# Today I Learned(TIL) Wiki

## :sparkles: 25.02.12(수)
[USER / PROJECT]
- [x] GetRes value 값 통일하기

### :white_check_mark: 새롭게 알게 된 점
#### CORS 
- 자원 공유. 다른 도메인에서 resource를 요청하게 된다면, 그 자원에 대한 corsAllow를 해줘야만 그 자원을 사용할 수 있다!

#### OAuth 로그인/회원가입 인증.
- OAuth: Open Authorization
```

```

## :sparkles: 25.02.10(월)
[INSTRUMENT]
- [x] 유저 악기 추가 및 조회
- [x] 프로젝트 악기, 기타 악기 조회

### :white_check_mark: 새롭게 알게 된 점
#### HTTPS swagger CORS 문제
```
public OpenAPI openAPI() {

    SecurityScheme securityScheme = new SecurityScheme()
            .type(SecurityScheme.Type.HTTP)
            .scheme("Bearer")
            .bearerFormat("JWT")
            .in(SecurityScheme.In.HEADER)
            .name("Authorization");

    SecurityRequirement securityRequirement = new SecurityRequirement().addList("bearerAuth");

    return new OpenAPI().servers(List.of(
                    new Server().url("https://api.blendeo.shop")  // HTTPS URL로 설정
                    ))
                    .components(new Components()
                    .addSecuritySchemes("bearerAuth", securityScheme)) // API 구성 요소를 설정합니다.
            .security(Arrays.asList(securityRequirement))
            .info(apiInfo()); // API 정보를 설정합니다.
}
```
### https://api.blendeo.shop/swagger-ui/index.html

에서 요청했지만 반환은 http로 요청이 되어서 CORS(리소스의 위치가 잘못 설정된 에러)

```
curl -X 'POST' \
	'http://api.blendeo.shop/api/v1/user/auth/login' \
	-H 'accept: */*' \
	-H 'Content-Type: application/json' \
	-d '{
	"email": "[test1@gmail.com](mailto:test1@gmail.com)",
	"password": "test1"
}
```

After Trouble Shooting
```
curl -X 'POST' \
  'https://api.blendeo.shop/api/v1/user/auth/login' \
  -H 'accept: */*' \
  -H 'Content-Type: application/json' \
  -d '{
  "email": "test1@gmail.com",
  "password": "test1"
}'
```
#### Spring Security
```
@Bean
    public SecurityFilterChain securityFilterChain(HttpSecurity http) throws Exception {
        http
                .cors(cors -> cors.configurationSource(corsConfigurationSource())) // CORS 설정 추가
                .csrf(csrf -> csrf.disable()) // CSRF 비활성화
                .authorizeHttpRequests(auth -> auth
                        // Swagger 관련 요청 인증 제외
                        .requestMatchers(
                                "/ws-stomp/**",
                                "/swagger-ui/**",
                                "/v3/api-docs/**",
                                "/swagger-resources/**",
                                "/webjars/**",
                                "/configuration/ui",
                                "/configuration/security",
                                "/api/v1/**"
                        ).permitAll()
                        // 나머지 요청은 인증 필요
                        .anyRequest().authenticated()
                )
                .addFilterBefore(jwtAuthenticationFilter, UsernamePasswordAuthenticationFilter.class) // JWT 필터 추가
                .httpBasic(AbstractHttpConfigurer::disable); // HTTP Basic 인증 비활성화
        return http.build();
    }
```
1. SecurityConfig: Filter는 애초에 이 웹 사이트에 들어가는 인증 권한을 점검한다.
-> 일반 유저와 웹 페이지 관리자 간 권한 인증!
-> 페이지 접근 권한이 없다면 401 ERROR 반환
2. HttpBasic 인증이 설정되어 있다면
-> 서버에서 www-authenticate: Basic realm="Realm" 로 응답해서 401에러가 발생


```
@Override
    protected boolean shouldNotFilter(HttpServletRequest request) throws ServletException {
        // Filter에 걸리면 안되는 url(로그아웃, 토큰 재발급)
        return request.getRequestURI().startsWith("/swagger-ui/index.html")
                || request.getRequestURI().startsWith("/swagger-ui")
                || request.getRequestURI().startsWith("/v3/api-docs")
                || request.getRequestURI().startsWith("/swagger-resources")
                || request.getRequestURI().startsWith("/api/v1/user/auth")
                || request.getRequestURI().startsWith("/api/v1/user/get-user")
                || request.getRequestURI().startsWith("/webjars")
                || request.getRequestURI().startsWith("/configuration")
                || request.getRequestURI().startsWith("/api/v1/project/new")
                || request.getRequestURI().startsWith("/api/v1/project/info")
                || request.getRequestURI().startsWith("/api/v1/rank")
                || request.getRequestURI().startsWith("/api/v1/instrument")
                || request.getRequestURI().startsWith("/ws-stomp");
    }
```
JwtTokenFilter는 accessToken 을 검증할 필터를 지정해준다.
-> accessToken이 잘못되었거나 들어오지 않았다면, 403 Forbidden ERROR을 반환한다.

## :sparkles: 25.02.07(금)
[CHAT]
- [x] MR 요청 및 충돌 해결

[INFRA]
- [x] 배포 방식 수정

### :white_check_mark: 새롭게 알게 된 점
#### SSE Emitter 사용하는 이유
- SSE : Server-Sent-Event의 약자. 서버에서 클라이언트로 실시간 이벤트를 전달하는 웹 기술
- 클라이언트 별도 추가요청 없이 서버에서 업데이트 스트리밍 가능

#### /pub, /sub websocket 실시간 메시지


## :sparkles: 25.02.06(목)
[CHAT]
- [x] webSocket 연결
- [x] 채팅방, 채팅메시지, 채팅방 참여자 저장 및 조회
- [x] /sub /pub 하면서 정보 가져오기

### :white_check_mark: 새롭게 알게 된 점
#### Transaction 충돌 문제.
```
2025-02-06T17:38:54.236+09:00  INFO 14248 --- [backend] [boundChannel-22] B.backend.chat.service.ChatService       : Sending message: 헬로
2025-02-06T17:38:54.237+09:00 DEBUG 14248 --- [backend] [boundChannel-22] o.s.d.n.c.t.Neo4jTransactionManager      : Creating new transaction with name [org.springframework.data.jpa.repository.support.SimpleJpaRepository.save]: PROPAGATION_REQUIRED,ISOLATION_DEFAULT
2025-02-06T17:38:54.241+09:00 DEBUG 14248 --- [backend] [boundChannel-22] o.s.d.n.c.t.Neo4jTransactionManager      : Initiating transaction commit
```

jpa로 MySQL에 값을 저장하는 데 Neo4j Transaction 이 실행이 되는 문제 발생!

```
// DatabaseConfig
@Configuration
public class DatabaseConfig {

    @Primary  // 이게 중요합니다!
    @Bean
    public PlatformTransactionManager transactionManager(EntityManagerFactory entityManagerFactory) {
        return new JpaTransactionManager(entityManagerFactory);
    }

    @Bean("jpaTransactionManager")  // 명시적으로 이름 지정
    public PlatformTransactionManager jpaTransactionManager(EntityManagerFactory entityManagerFactory) {
        return new JpaTransactionManager(entityManagerFactory);
    }
}

// Neo4jConfig
public class Neo4jConfig {
    @Bean("neo4jTransactionManager")
    public Neo4jTransactionManager neo4jTransactionManager(Driver driver,               DatabaseSelectionProvider databaseSelectionProvider) {
        return new Neo4jTransactionManager(driver, databaseSelectionProvider);
    }
}

```
생성자 주입으로 Qulifier 로 어떤 템플릿을 사용할 것인지 명시적으로 지정.
```
public ChatService(@Qualifier("chatRedisTemplate") RedisTemplate<String, Object> chatRedisTemplate) {
    this.chatRedisTemplate = chatRedisTemplate;
}
```


transactionManager 함수가 동일해서 발생하는 문제.
다음과 같이 Bean의 이름을 지정해주면 해결 가능!

#### WebSocket 통신과 Security 충돌.
- ws: 접속할 때 SecurityConfig 접근 불가능한 문제가 발생.
- SecurityConfig, JwtAuthenticationFilter(shouldNotFilter)에 해당 URL 인증 제외

## :sparkles: 25.02.04(화)
[PROJECT]
- [x] 영상 랜더링 합치기
[BACK-FRONT]
- [x] 자잘한 url 수정
- [x] 유저 Set-Cookie로 accessTokne, refreshToken 넘겨주기

### :white_check_mark: 새롭게 알게 된 점
#### **로그인 accessToken refreshToken 넘기기**
- accessToken, refreshToken 발급 후, Set-Cookie에 담아서 response에 넘겨야함.
- 새로고침해도 값이 날라가지 않고, logout 하거나, 토큰이 만료되었을 때 사라짐.
- HTTPS 환경에서만 secure 처리를 해야함.
- 프론트에서는 withCredential: true로 설정하여 자동적으로 쿠키에 들어있는 값을 가져오도록 함.
- accessToken 이 만료되었을 때, refresh 할 때는 refreshToken 으로 그 인증자가 맞는지 확인하고 accessToken을 재발급해줌.
- 쿠키에서 HttpOnly를 적용하면, javascript에서 직접 accessToken, refreshToken을 가져올 수 없음.
=> XSS(Cross Site Scripting) 공격 : 자바스크립트와 같은 스크립트 코드를 삽입해 개발자가 고려하지 않은 기능이 작동되게 하는 공격.


## :sparkles: 25.01.24(금)
[USER]
- [x] doFilterInternal - accessToken 만료) refresh 토큰 검증하는 로직 추가 필요!
- [ ] signup) 주로 사용하는 악기 추가 필요!
- [ ] 이메일 인증 API - 만료 기간 관리하기!
- [ ] User 이미지 S3 연결.

[CHAT]
- [x] 1:N 채팅 구현 방식 자료조사 -> STOMP, Redis 연동!
- [x] 1:N 채팅 erd 상세하게 설정 
- [x] Kafka(메시지 큐) 서버 로컬 연결

### :white_check_mark: 새롭게 알게 된 점
#### **WSL**
- Kafk(메시지 큐) 서버를 window에 다운 받으면서 docker, docker-compose 필요해짐
- docker desktop 다운으로 해결!
- 이 과정에서 WSL -> window, linux 연결하는 것!에 대해 알아보게 됨.

#### **S3 비디오 업로드/영상 파일 조회 방식**
[클라이언트 -> 서버 -> S3 업로드]
1. S3에 영상을 업로드하게 되면, Multipart 로 이미지가 전송되고, 그 값을 S3에 저장하게 된다.
2. S3는 서버에 링크를 반환하고, 서버는 클라이언트에게 URL을 반환한다.

[클라이언트(url) -> 서버(url) -> S3 -> 서버(video) -> 클라이언트(video) 파일 GET!]
1. 클라이언트가 서버에게 url을 전달하면, 서버는 S3에게 파일을 요청한다.
2. S3는 비디오를 Multipart로 반환하고, 그 값을 클라이언트에게 전달한다.


## :sparkles: 25.01.23(목)
[USER]
- [ ] ~doFilterInternal - accessToken 만료) refresh 토큰 검증하는 로직 추가 필요!~
- [ ] swagger에서 header 입력 가능하도록 수정 필요!

### :white_check_mark: 새롭게 알게 된 점
#### **Swagger와 Advice Handler 의 Swagger 버전 문제로 발생한 오류**
- NoSuchMethod. 오류가 뜸.
- 버전 호환성이 매우 중요하다.

## :sparkles: 25.01.22 (수)
- [x] 이메일 인증 API - 이메일이 존재하는지 검증 추가해야함.
- [x] 로그인 API - refresh Token 삭제하는 방식으로 다시 적용.
- [x]] 예외처리 후 기능 구현 완료!


### :white_check_mark: 새롭게 알게 된 점
#### :bulb:**SOLID 객체 지향 원칙**
> 효과: 코드를 확장하고 유지 보수 관리가 더 쉬워지며, 복잡성을 제거해 개발의 생산성을 높임.
##### **S: 단일 책임 원칙**
- 클래스(객체)는 단 하나의 책임만 가져야 한다.
    - 하나의 클래스는 하나의 기능을 담당하여 하나의 책임을 수행
##### **O: 개방 폐쇄 원칙**
- 확장엔 열려있어야 하며, 수정에는 닫혀있어야 한다.
    - [확장에 열려있다] - 새로운 변경 사항 발생했을 때, 유연하게 코드를 추가할 수 있음.
    - [변경에 닫혀있다] - 새로운 변경 사항이 발생했을 때, 객체 직접적 수정 제한
##### **L: 리스코프 치환 법칙**
- 서브 타입은 언제나 부모 타입으로 교체할 수 있어야 한다.
##### **I: 인터페이스 분리 원칙**
- 인터페이스를 각각 사용에 맞게 잘게 분리해야 한다.
- 인터페이스의 단일 책임 강조
##### **D: 의존 역전 원칙**
- Class를 참조해서 사용해야하는 상황이라면, 직접 참조보단, 대상의 상위 요소(추상 클래스 or 인터페이스)로 참조해야한다.
- 구현 클래스에 의존하지 말고, 인터페이스에 의존하라.

#### :bulb:**JWT 토큰 처리 | doFilterInternal 프로세스**
##### **doFilterInternal: Filter의 핵심 메서드 <- OncePerRequestFilter 상속 받아 구현**
- DispatcherServlet 이전에 실행되는 Spring Filter 체인 내에서 작동함.
- Request 들어왔을 때, 작동 순서
    1. Filter 체인의 앞쪽에 위치한 필터들이 요청을 처리
    2. 사용자 정의 doFilterInternal 메서드 실행
    3. 필터 체인을 통해 요청이 DispatcherServlet에 도달


#### :bulb:**AOP**

##### **AOP란?**

##### **BaseException** 예외처리

##### **@ControllerAdvice의 작동 순서**
1. 요청이 DispatcherServlet을 통해 Controller로 전달.
2. Controller에서 예외가 발생하면, @ControllerAdvice에 정의된 ExceptionHandler 메서드 실행
3. ExceptionHandler는 클라이언트에 응답 반환.

##### **doFilterInternal, @ControllerAdvice 통합**
1. 요청(Request) → 필터 체인 실행 (doFilterInternal 실행 포함)
2. DispatcherServlet 실행
Controller로 요청 전달
3. Controller에서 작업 수행
- 정상 처리: 응답(Response)을 필터 체인으로 반환
- 예외 발생: @ControllerAdvice의 ExceptionHandler 작동
5. 클라이언트로 최종 응답 반환


### :white_check_mark: 어려웠던 점


## :sparkles: 25.01.21 (화)
- [ ] 회원가입 API - 이메일이 존재하는지 검증 추가해야함.
- [x] 로그인 access Token, refresh Token Redis 저장
- [x] 로그아웃 블랙리스트 관리
- [x] 회원정보 수정/회원탈퇴 API

### :white_check_mark: 새롭게 알게 된 점
#### :bulb:**로그인/로그아웃 프로세스**
> (Spring + JWT + Redis 사용)

**<로그인>**
1. 유저가 정보를 입력하고 로그인한다.
2. 서버에서 accessToken, refreshToken 을 생성하여 Redis DB에 저장하고, 두 값을 클라이언트에게 반환한다.

**<로그아웃>**
1. 유저가 로그아웃 버튼을 누른다.
2. accessToken을 보내면 Redis DB에 ```"BlackList: "+accessToken``` 값을 저장하고,
refreshToken을 삭제한다.
> (다른 방법) accessToken, refreshToken 둘 다 삭제(?)
3. 로그아웃 된다.

**<유저가 다른 기능 사용할 때>**
1. 가지고 있는 accessToken을 헤더에 포함해서 자원을 요청한다.
2. accessToken이 BlackList에 있다면, 이미 토큰이 만료되었음을 알 수 있다.
3. doFilterInternal 에서 인증 관리를 하면, 기능 접근 불가!

##### Refresh Token의 필요성
```
토큰의 유효시간이 짧다면 -> 공격하는 사람이 탈취해도 금방 토큰이 만료됨.
 => 유효성 통과를 금방 하지 못하게 될 것.
BUT, 문제는 이렇게 되면 사용자는 계속 로그인을 반복해야하는 불편함 생김.

따라서, RefreshToken으로 다시 accessToken 발급 가능하도록, RefreshToken 도입!
```

### :white_check_mark: 어려웠던 점
#### :bulb:**스프링부트 시큐리티 의존성 추가로 일어나는 일들**
```
implementation 'org.springframework.boot:spring-boot-starter-security'
```
를 추가하면서 모든 url 접근에 인증이 필요해짐.
=> SecurityConfig 에서 securityFilterChain 에서 요청 인증을 제외해야함.
spring 버전마다 securityFilter 설정 방식이 다름!!
https://ttasjwi.tistory.com/148


## :sparkles: 25.01.20 (월)
- [ ] 회원가입 API - 이메일이 존재하는지 검증 추가해야함.
- [ ] 로그인 access Token 
- [ ] 로그인 예외처리 후 기능 구현 완료!
- [ ] 1:N 채팅 구현 방식 자료조사
- [ ] 1:N 채팅 erd 상세하게 설정


### :white_check_mark: 새롭게 알게 된 점
#### access Token vs. refresh Token

#### Redis
- in-memory에 있는 값을 조회하기 때문에 RDBMS 보다 데이터 접근 속도가 빠르다.
=> 로그인 access Token 과 refresh Token 을 redis로 관리.

### :white_check_mark: 어려웠던 점
> 편집 화면 구성 회의에 3시간을 썼음.
> 개발 시간 관리를 하며 회의를 해야할 것 같음!
> 화이팅!

## :sparkles: 25.01.17 (금)
- [x] 회원가입 API - 이메일 인증
- [x] 회원가입 API - 암호화
- [x] 로그인 API
- [ ] 1:N 채팅 구현 방식 자료조사
- [ ] 1:N 채팅 erd 상세하게 설정

### 오늘 추가 To-do
- [ ] 회원가입 API - 이메일이 존재하는지 검증 추가해야함.
- [ ] 예외처리 방식 확정 및 정리해보기!
- [ ] 로그인 예외처리 후 기능 구현 완료!

### :white_check_mark: 새롭게 알게 된 점
#### :bulb: **이메일 인증: spring-boot-starter-mail**
##### SMTP 사용
- spring-boot-starter-mail 라이브러리 추가
- 6자리 인증코드 랜덤으로 생성
- javaMailSender 빈을 주입 받고, content를 MimeMessage 객체에 담아서 이메일을 전송한다.
##### SMTP(Simple Mail Transfer Protocol) 란?
> **전자메일 전송할 때 쓰이는 표준 프로토콜**
> - 포트번호 465 or 587 사용
##### 포트번호 465 vs. 587
- 포트 465: *SMTP용*으로 SMTP 암호화 전에 SMTP 암호화가 자동으로 시작.
- 포트 587: *msa용*으로 표준 SMTP 포트와 거의 같음.
=> 보안상, 되도록 587포트를 사용하도록 권장

#### :bulb:**암호화: spring-security-web**
- spring-security-web 라이브러리 추가
##### Spring Security 란?
> 자바 서버 개발을 위해 필요로 한 인증, 권한 부여 및 기타 보안 기능을 제공하는 프레임워크
- BCryptPasswordEncoder 포함
##### BCryptPasswordEncoder 란?
- BCrypt 해싱 함수(BCrypt hashing function)를 사용해서 비밀번호를 인코딩 메서드 제공
- 사용자의 의해 제출된 비밀번호와 저장소에 저장되어 있는 비밀번호의 일치 여부를 확인해주는 메서드 제공 

#### :bulb:**생성자 주입 vs. @Autowired**
##### 생성자 주입
- 순환 참조 방지 가능!!
- 생성자로 객체를 생성하는 시점에 필요한 빈을 주입.
- 생성자의 인자에 사용되는 빈을 찾거나 빈 팩토리에서 만듦.
- 그 후에 찾은 인자 빈으로 주입하려는 빈의 생성자를 호출.
-> **먼저 빈 생성 X**
##### 필드 주입(@Autowired)
- 먼저 빈을 생성한 후, 어노테이션이 붙은 필드에 해당하는 빈을 찾아서 주입함.
-> **먼저 빈을 생성**한 후 필드에 대해 주입

#### :bulb:**로그인 POST vs. GET**
- GET 방식으로 URL에 아이디와 비밀번호를 담아서 요청을 보내게 되면 보안상 취약하게 느껴짐.

### :white_check_mark: 어려웠던 점
<hr/><hr/>

## :sparkles: 25.01.16 (목)
- [x] swagger 연동
- [x] neo4j local 환경에서 연동
- [x] 회원가입 API - 이메일 인증, 암호화 X
- [ ] 로그인 API

### 기획
- 채팅) 다시 설계 필요함. 추가 업로드 예정!

### DB - neo4j
- [문법]
    -  CREATE: 노드, 관계를 생성
    > create (짱구:Person {name:'짱구'}),(맹구:Person {name:'맹구'}),(흰둥이:Dog {name:'흰둥이'}), (짱구)-[:friend]->(맹구),(맹구)-[:friend]->(짱구),(흰둥이)-[:master]->(짱구)

    -  MATCH: 기존 노드, 관계를 검색. WHERE과 함께 쓰면 조건부 검색 가능.
    > MATCH < pattern > WHERE < conditions > RETURN < expression >
    > ex) match (p:Person{name:"짱구"}) set p.age=5,p.gender='male' return p


## :sparkles: 25.01.15 (수)

### 기획
- ERD 설계 수정 필요성 발견
    - 프로젝트 간의 자식, 부모 노드들의 전체 관계를 확인할 수 있는 "가족관계도" 필요해짐.
    - Graph DB 사용의 필요성 => Neo4j 활용하는 것으로 결정

### DB
- Graph DB란?
    - 노드(node)와 엣지(edge)로 표현하는 데이터베이스
    - GDB vs. RDB
        - RDB와 다르게 Join 연산을 통해 두 개체를 연결하는 것이 아닌, 바로 간선을 통해 탐색을 하여 쿼리 속도 향상.


## :sparkles: 25.01.14 (화)

### 기획
- 와이어프레임 작성하면서 세부 기능들 확정.
- 채팅) 메시지 읽음/안읽음 표시
    - STOMP 방식으로 Redis를 활용한 readCount 정보 관리.
    
    채팅을 하는 두 명 모두가 채팅방에 있는 경우

    Stomp를 기반으로한 pub/sub 구조이므로 프론트엔드에서 subscribe 하자마자 서버에게 메시지를 읽었음을 알린다.
    이 때 /chat/{chat-id} 라는 엔드포인트로 요청을 보내 서버에게 메시지 읽었음을 알린다.
    위 요청을 받으면 서버는 chat-id에 해당하는 채팅의 readCount를 감소시킨다. 
    이런 방식을 사용하면 subscriber가 두명이므로 readCount가 2만큼 감소하게 되고, readCount가 0인 것을 통해 해당 채팅은 두 명 모두가 읽었음을 확인할 수 있다.


    한명만 채팅방에 있는 경우 

    위 방식대로 하면 readCount는 1이 감소하게 된다. (채팅방의 subscriber가 한명이므로)
    남은 readCount 1은 나머지 한명이 채팅방을 불러올 때 readCount를 1 감소시킨다. 
    주의) 채팅방을 불러올 때 내가 발신자가 아닌 경우 && readCount == 1 인 경우만 readCount를 1 감소시킨다.



    위와 같은 방식을 사용하면 readCount 라는 값을 통해 채팅을 상대방이 읽었는지 여부를 알 수 있게 되고, 이를 통해 안읽은 메시지가 몇개 인지도 파악할 수 있게 됩니다.
    => 출처: https://kjhoon0330.tistory.com/entry/Spring-채팅-읽음-확인-기능-구현하기#2. 1. 요구사항📕 [Jahni's Blog:티스토리]

### 어려웠던 점.
- 6인 프로젝트트 협업에서의 어려움을 깨달음.
    - 전체적인 그림을 그리고, 그 후로 와이어프레임과 ERD 설계를 하는 것이 좋다.
    - 동일한 것에 대해 생각하는 것이 모두 다름. (:sparkles: 소통의 중요성)


## :sparkles: 25.01.13 (월)

### 기획

- 프로젝트 명 확정
    - Blendeo (Blend + video)
- 비디오 루프스테이션 대상 설정
    - ABC 로 동영상이 쌓였다면, 사이의 동영상 수정 및 삭제 불가능.

### DB 설계
- erdCloud 로 협업
    - git 과 유사하게, 동영상 fork 하는 방식 토의
