# Today I Learned(TIL) Wiki

## :sparkles: 25.01.17 (금)
- [x] 회원가입 API - 이메일 인증
- [x] 회원가입 API - 암호화
- [x] 로그인 API
- [ ] 1:N 채팅 구현 방식 자료조사
- [ ] 1:N 채팅 erd 상세하게 설정

### 오늘 추가 To-do
- [ ] 회원가입 API - 이메일이 존재하는지 검증 추가해야함.
- [ ] 예외처리 방식 확정 및 정리해보기!
- [ ] 로그인 예외처리 후 기능 구현 완료!

### :white_check_mark: 새롭게 알게 된 점
#### :bulb: **이메일 인증: spring-boot-starter-mail**
##### SMTP 사용
- spring-boot-starter-mail 라이브러리 추가
- 6자리 인증코드 랜덤으로 생성
- javaMailSender 빈을 주입 받고, content를 MimeMessage 객체에 담아서 이메일을 전송한다.
##### SMTP(Simple Mail Transfer Protocol) 란?
> **전자메일 전송할 때 쓰이는 표준 프로토콜**
> - 포트번호 465 or 587 사용
##### 포트번호 465 vs. 587
- 포트 465: *SMTP용*으로 SMTP 암호화 전에 SMTP 암호화가 자동으로 시작.
- 포트 587: *msa용*으로 표준 SMTP 포트와 거의 같음.
=> 보안상, 되도록 587포트를 사용하도록 권장

#### :bulb:**암호화: spring-security-web**
- spring-security-web 라이브러리 추가
##### Spring Security 란?
> 자바 서버 개발을 위해 필요로 한 인증, 권한 부여 및 기타 보안 기능을 제공하는 프레임워크
- BCryptPasswordEncoder 포함
##### BCryptPasswordEncoder 란?
- BCrypt 해싱 함수(BCrypt hashing function)를 사용해서 비밀번호를 인코딩 메서드 제공
- 사용자의 의해 제출된 비밀번호와 저장소에 저장되어 있는 비밀번호의 일치 여부를 확인해주는 메서드 제공 

#### :bulb:**생성자 주입 vs. @Autowired**
##### 생성자 주입
- 순환 참조 방지 가능!!
- 생성자로 객체를 생성하는 시점에 필요한 빈을 주입.
- 생성자의 인자에 사용되는 빈을 찾거나 빈 팩토리에서 만듦.
- 그 후에 찾은 인자 빈으로 주입하려는 빈의 생성자를 호출.
-> **먼저 빈 생성 X**
##### 필드 주입(@Autowired)
- 먼저 빈을 생성한 후, 어노테이션이 붙은 필드에 해당하는 빈을 찾아서 주입함.
-> **먼저 빈을 생성**한 후 필드에 대해 주입

#### :bulb:**로그인 POST vs. GET**
- GET 방식으로 URL에 아이디와 비밀번호를 담아서 요청을 보내게 되면 보안상 취약하게 느껴짐.

### :white_check_mark: 어려웠던 점
<hr/><hr/>

## :sparkles: 25.01.16 (목)
- [x] swagger 연동
- [x] neo4j local 환경에서 연동
- [x] 회원가입 API - 이메일 인증, 암호화 X
- [ ] 로그인 API

### 기획
- 채팅) 다시 설계 필요함. 추가 업로드 예정!

### DB - neo4j
- [문법]
    -  CREATE: 노드, 관계를 생성
    > create (짱구:Person {name:'짱구'}),(맹구:Person {name:'맹구'}),(흰둥이:Dog {name:'흰둥이'}), (짱구)-[:friend]->(맹구),(맹구)-[:friend]->(짱구),(흰둥이)-[:master]->(짱구)

    -  MATCH: 기존 노드, 관계를 검색. WHERE과 함께 쓰면 조건부 검색 가능.
    > MATCH < pattern > WHERE < conditions > RETURN < expression >
    > ex) match (p:Person{name:"짱구"}) set p.age=5,p.gender='male' return p


## :sparkles: 25.01.15 (수)

### 기획
- ERD 설계 수정 필요성 발견
    - 프로젝트 간의 자식, 부모 노드들의 전체 관계를 확인할 수 있는 "가족관계도" 필요해짐.
    - Graph DB 사용의 필요성 => Neo4j 활용하는 것으로 결정

### DB
- Graph DB란?
    - 노드(node)와 엣지(edge)로 표현하는 데이터베이스
    - GDB vs. RDB
        - RDB와 다르게 Join 연산을 통해 두 개체를 연결하는 것이 아닌, 바로 간선을 통해 탐색을 하여 쿼리 속도 향상.


## :sparkles: 25.01.14 (화)

### 기획
- 와이어프레임 작성하면서 세부 기능들 확정.
- 채팅) 메시지 읽음/안읽음 표시
    - STOMP 방식으로 Redis를 활용한 readCount 정보 관리.
    
    채팅을 하는 두 명 모두가 채팅방에 있는 경우

    Stomp를 기반으로한 pub/sub 구조이므로 프론트엔드에서 subscribe 하자마자 서버에게 메시지를 읽었음을 알린다.
    이 때 /chat/{chat-id} 라는 엔드포인트로 요청을 보내 서버에게 메시지 읽었음을 알린다.
    위 요청을 받으면 서버는 chat-id에 해당하는 채팅의 readCount를 감소시킨다. 
    이런 방식을 사용하면 subscriber가 두명이므로 readCount가 2만큼 감소하게 되고, readCount가 0인 것을 통해 해당 채팅은 두 명 모두가 읽었음을 확인할 수 있다.


    한명만 채팅방에 있는 경우 

    위 방식대로 하면 readCount는 1이 감소하게 된다. (채팅방의 subscriber가 한명이므로)
    남은 readCount 1은 나머지 한명이 채팅방을 불러올 때 readCount를 1 감소시킨다. 
    주의) 채팅방을 불러올 때 내가 발신자가 아닌 경우 && readCount == 1 인 경우만 readCount를 1 감소시킨다.



    위와 같은 방식을 사용하면 readCount 라는 값을 통해 채팅을 상대방이 읽었는지 여부를 알 수 있게 되고, 이를 통해 안읽은 메시지가 몇개 인지도 파악할 수 있게 됩니다.
    => 출처: https://kjhoon0330.tistory.com/entry/Spring-채팅-읽음-확인-기능-구현하기#2. 1. 요구사항📕 [Jahni's Blog:티스토리]

### 어려웠던 점.
- 6인 프로젝트트 협업에서의 어려움을 깨달음.
    - 전체적인 그림을 그리고, 그 후로 와이어프레임과 ERD 설계를 하는 것이 좋다.
    - 동일한 것에 대해 생각하는 것이 모두 다름. (:sparkles: 소통의 중요성)


## :sparkles: 25.01.13 (월)

### 기획

- 프로젝트 명 확정
    - Blendeo (Blend + video)
- 비디오 루프스테이션 대상 설정
    - ABC 로 동영상이 쌓였다면, 사이의 동영상 수정 및 삭제 불가능.

### DB 설계
- erdCloud 로 협업
    - git 과 유사하게, 동영상 fork 하는 방식 토의
